# 1章から5章の復習

## 始まる前に

あくまでも1章~15章を読んでからの復習のため、1章~15章で書いた詳細な内容については割愛して感想と本を読んだ後の成長を中心に話します。


## 1章(オブジェクト、設計)

### 内容

1章では劇場のチケットを販売するプログラムを例として説明します。   
例のプログラムはまず従来型により実装します。   
その後、従来型からオブジェクト型に実装を変更して従来型とオブジェクト型の特徴、違い、メリットとデメリットについて説明します。


### 感想

昔は従来型からオブジェクト型に変更するのは本を参考せずにできませんでしたが、慣れたおかげか苦労なく変更できました。  
また、なぜ従来型ではなくオブジェクト型の実装にすべきかより分かるようになったと思います。

## 2章(オブジェクトプログラミング)

### 内容

2章では映画予約プログラムを例として説明します。   
プログラムの中でオブジェクトプログラミングに重要な概念（継承、インタフェース、コンポジション）について説明します。

### 感想

本ではプログラミングに重要な概念（継承、インタフェース、コンポジション）について最初から最後まで述べていました。
何度も触れたおかげか復習する時に上記の概念について既に理解していたと思います。   
私が思った継承、インタフェース、コンポジションはこちらで本と同じでした。   

+ 継承

二つの目的のために使われる。
1. 親クラスのコードを再利用
2. 多態性を使う   

継承とインタフェースは多態性を使う目的は同じです。  
しかし、継承の場合「親クラスのコードを再利用」できるメリットがある反面、「子クラスが親クラスの実装に依存する」デメリットがあります。   
そのため、継承とインタフェースを使う時はトレードオフを考えてどちらを使うか選ぶべきです。

+ インタフェース

多態性を使うために使われる。   
継承より子クラスが親クラスに依存性が低い。  

+ コンポジション

クラス同士が協力するために使う。   

例)
```
class A {
    B b;

    A(B b) {
        this.b = b;
    }

    .... method(){
        b.method();
    }
}

class B {
    ... method(){

    }
}

AクラスがBをコンポジションする
```
コンポジションを使うと依存性を低くしてクラス同士が協力することができます。   

## 3章(役割、責任、協力)

### 内容

3章では役割、責任、協力について説明します。  
+ 役割  
ある協力の中で遂行する責任の集まり(抽象化、インタフェース)
+ 責任  
協力に参加するためにクラスが行う行動
+ 協力  
アプリケーションの機能を実装するために行うコミュニケーション

オブジェクトプログラミングの設計は上記の役割、責任、協力を基に設計するのが大事だと言っています。   

### 感想

2章の映画予約プログラムを役割、責任、協力を基に設計してみました。  
その結果、2章の本通りに設計ができました。   
2章だけを見て設計をする時は本と違う設計になったのですが、上記の概念を考えながら設計したら同じ結果になりました。   
もう一度役割、責任、協力の概念の大切さについて分かりました。

## 4章(設計品質とトレードオフ)

### 内容

4章では2章の映画予約プログラムをオブジェクト指向の設計ではなくデータ中心の設計（従来プログラミング）により
開発します。   
二つの違いを比較してなぜオブジェクト指向の設計の品質がいいのかを説明します。  
品質の判断には結合度と凝集度を使って判断します。   
+ 結合度   
あるクラスが他のクラスについてどれくらい知っているかのこと。   


+ 凝集度   
修正が発生する時にどれくらいクラスを修正する必要があるのかのこと。   


よい品質は結合度は低く、凝集度は強くすることだと言います。   
そうするためにはカプセル化を守ることが大事だと言います。   
+ カプセル化  
変更が発生うるような実装は隠して変更が発生しないような実装だけ外部に公開すること。  
正し、クラスの属性をprivateにしてもその属性に対してsetterとgetterメソッドがある場合はカプセル化したと見なされない。  

### 感想

この章の内容によってちゃんと理解できなかった結合度と凝集度について理解できるようになったと思います。   
また、結合度と凝集度が修正にどれくらい影響するのかも分かるようになりました。

## 5章(責任を割り当てる)

### 内容

5章では正しく責任を割り当てる方法を説明します。   

その方法がGRASP(General Responsibility Assignment Software Pattern[一般的な責任を割り当てるソフトウェアパターン])です。
GRASPは以下ルールより責任を割り当てることになっています。   

+ INFORMATION EXPERT(情報専門家)

  責任割り当てる時にはその情報を一番分かっている専門家に委任する。

+ LOW COUPLING(低い結合度)

  クラスとクラスの依存性を低くする。

+ HIGH COHESION(高い凝集度)

  関連があるクラス同士で協力する。

+ CREATOR(生成者)

  仮にAクラスを生成する時にはどのクラスで生成するかを決めるパターン  
以下の条件を多く満たす場合に割り当てる

  1. Aクラスを含んだり参照している。

  2. Aクラスを記録している。

  3. Aクラスをよく使っている。

  4. Aクラスを生成するための情報を持っている。  

最後に上記の方法より[https://github.com/bittap/study/tree/main/src/main/java/com/my/study/object/chapter01~05#4%E7%AB%A0%E8%A8%AD%E8%A8%88%E5%93%81%E8%B3%AA%E3%81%A8%E3%83%88%E3%83%AC%E3%83%BC%E3%83%89%E3%82%AA%E3%83%95](データ中心の設計)をオブジェクト設計に変更するのを説明します。  

### 感想

1読で勉強した内容だったのにすっかり忘れていました。
忘れないように気を付けたいと思います。
そのために、GRASP(General Responsebiliby Assginment Software Pattern)というキーワードを覚えておいたほうがよいと思いました。   
GRASPパータンの個々のルールは忘れがちなのでそのルール達を含めるキーワードさえ覚えれば困らないと思いました。

そして、設計する上でどのクラスに責任を割り当てるか迷う場面が多いです。   
上記の方法であれば合理的にどのクラスに割り当てるか判断できると思います。


